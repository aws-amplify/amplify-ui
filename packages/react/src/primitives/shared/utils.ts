import { useId } from '@radix-ui/react-id';

export const strHasLength = (str: unknown): str is string =>
  typeof str === 'string' && str.length > 0;

export const isFunction = (fn: unknown): fn is Function =>
  typeof fn === 'function';

export const isNullOrEmptyString = (value: unknown) =>
  value == null || (typeof value === 'string' && value.length === 0);

/**
 * Create a consecutive integer array from start value to end value.
 * @param start start value
 * @param end end value
 * @returns an integer array with elements from start to end consecutively
 */
export const getConsecutiveIntArray = (start: number, end: number) => {
  const length = end - start + 1;
  return Array.from({ length }, (_, idx) => idx + start);
};

/**
 * Create a uuid to use with amplify fields unless
 * an id is provided
 * @param id user specified id
 * @returns string
 */
export const useStableId = (id?: string) => useId(id);

/**
 * Determine whether a component is controlled or not
 * @param value the value for a component
 * @returns boolean
 */
export const isControlledComponent = (value: any) => value !== undefined;

// Prefixed autogenerated id created by useStableId
export const AUTO_GENERATED_ID_PREFIX = 'radix-id-';

/**
 * This method is used to parse through all of the overrides and
 * only pass the relevant child overrides for a given component.
 * @param overrides escape hatch props
 * @param elementHierarchy
 * @returns overrides only for specified element
 */
export const findChildOverrides = (
  overrides: EscapeHatchProps | null | undefined,
  elementHierarchy: string
) => {
  if (!overrides) {
    return null;
  }

  const filteredOverrides = Object.entries(overrides).filter((m) =>
    m[0].startsWith(elementHierarchy)
  );

  return Object.assign(
    {},
    ...Array.from(filteredOverrides, ([k, v]) => ({
      [k.replace(elementHierarchy, '')]: v,
    }))
  );
};

/**
 * This helper method is used to get the overrides
 * that will be applied to a component
 * @param overrides escape hatch props
 * @param elementHierarchy
 * @returns component overrides
 */
export const getOverrideProps = (
  overrides: EscapeHatchProps | null | undefined,
  elementHierarchy: string
) => {
  if (!overrides) {
    return null;
  }

  const componentOverrides = Object.entries(overrides)
    .filter((m) => m[0] === elementHierarchy)
    .flatMap((m) => {
      const values = Object.entries(m[1]);
      return [values[0], values[1]];
    })
    .filter((m) => m?.[0]);

  return Object.fromEntries(componentOverrides);
};

export type EscapeHatchProps = {
  [elementHierarchy: string]: Record<string, string>;
};

export type VariantValues = { [key: string]: string };

export type Variant = {
  variantValues: VariantValues;
  overrides: EscapeHatchProps;
};

/**
 * Given a list of style variants, select a given one based on input props
 * @param variants list of style variants to select from
 * @param selectedVariantValues variant values to select from the list
 */
export function getOverridesFromVariants(
  variants: Variant[],
  selectedVariantValues: VariantValues
) {
  const matchedVariants = variants.filter(({ variantValues }) => {
    return (
      Object.keys(variantValues).length ===
        Object.keys(selectedVariantValues).length &&
      Object.entries(variantValues).every(
        ([key, value]) => selectedVariantValues[key] === value
      )
    );
  });

  return matchedVariants.reduce((overrides, variant) => {
    return { ...overrides, ...variant.overrides };
  }, {});
}
