### Rendering Optimizations

Using the overarching `useAuthenticator` at your app level is risky because it'll trigger re-render down the tree whenver any of its context change. Therefore, you should prefer scoped `useAuthenticator*` hooks like `useAuthenticatorUser`. But if you want to use `useAuthenticator` directly, there are two optimization strategies: `useAuthenticator(select)` and `React.useMemo`.

### useAuthenticator(selector)

`useAuthenticator` takes in an optional `selector` option that selects which context should be returned from `useAuthenticator`. This hook will only trigger a re-render if that selected value changes. For example,

```tsx
const user = useAuthenticator((context) => context.user);
```

will only trigger re-render when the `user` changes. This is what `useAuthenticatorUser` uses under the hood!

You can also select multiple context:

```tsx
const { user, route } = useAuthenticator((context) => ({
  user: context.user,
  route: context.route,
}));
```

will only trigger re-render when either `user` or `route` change.

### React.useMemo

Alternatively, you can make optimization application-side by using `React.useMemo` to decide when to re-render:

```tsx
import * as React from 'react';
import { useAuthenticator } from '@aws-amplify/ui-react';

const App = () => {
  const { route } = useAuthenticator();
  const HomeMemo = React.useMemo(() => <Contents />, [route]);
  const LoginMemo = React.useMemo(() => <Login />, [route]);

  return route === 'authenticated' ? <HomeMemo /> : <LoginMemo />;
};
```

Now, neither `<Home />` or `<Login />` will be re-rendered unless `route` changes. However, we suggest you use scoped `useAuthenticator*` hooks or `selectors` so that you are only subscribed to contexts you are interested in.
